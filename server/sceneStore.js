import { randomUUID } from 'crypto';
import { getDb } from './db.js';

/**
 * Scene CRUD operations
 */

export function listScenesByProject(projectId) {
    const db = getDb();

    // Fetch scenes ordered by scene_order
    const scenes = db.prepare(`
    SELECT * FROM scenes 
    WHERE project_id = ? 
    ORDER BY scene_order ASC
  `).all(projectId);

    if (scenes.length === 0) return [];

    // Fetch all assets for these scenes
    const sceneIds = scenes.map(s => s.id);
    const placeholders = sceneIds.map(() => '?').join(',');

    const sceneAssets = db.prepare(`
    SELECT sa.scene_id, a.id as assetId, a.url, a.name, a.type
    FROM scene_assets sa
    JOIN assets a ON sa.asset_id = a.id
    WHERE sa.scene_id IN (${placeholders})
    ORDER BY sa.scene_id
  `).all(...sceneIds);

    // Group assets by scene
    const assetsByScene = {};
    sceneAssets.forEach(sa => {
        if (!assetsByScene[sa.scene_id]) {
            assetsByScene[sa.scene_id] = [];
        }
        assetsByScene[sa.scene_id].push({
            id: sa.assetId,
            url: sa.url,
            name: sa.name,
            type: sa.type
        });
    });

    // Attach assets to scenes
    return scenes.map(scene => ({
        id: scene.id,
        projectId: scene.project_id,
        order: scene.scene_order,
        content: scene.content,
        assets: assetsByScene[scene.id] || [],
        createdAt: scene.created_at,
        updatedAt: scene.updated_at
    }));
}

export function updateProjectScenes(projectId, scenesData) {
    const db = getDb();

    const updateTransaction = db.transaction((scenes) => {
        const now = new Date().toISOString();

        const existingRows = db.prepare('SELECT id FROM scenes WHERE project_id = ?').all(projectId);
        const existingIds = new Set(existingRows.map(r => r.id));
        const incomingIds = new Set(scenes.map(s => s.id).filter(id => !id.startsWith('temp-'))); // clear temp IDs

        // Delete removed scenes
        for (const row of existingRows) {
            if (!incomingIds.has(row.id)) {
                db.prepare('DELETE FROM scenes WHERE id = ?').run(row.id);
            }
        }

        // Upsert scenes
        for (const scene of scenes) {
            const isNew = !existingIds.has(scene.id) || scene.id.startsWith('temp-');
            // If it's a temp ID (generated by frontend for new scene), generate a new UUID
            const sceneId = isNew ? (scene.id.startsWith('temp-') ? randomUUID() : scene.id) : scene.id;

            if (isNew) {
                db.prepare(`
          INSERT INTO scenes (id, project_id, scene_order, content, created_at, updated_at)
          VALUES (?, ?, ?, ?, ?, ?)
        `).run(sceneId, projectId, scene.order, scene.content || '', now, now);
            } else {
                db.prepare(`
          UPDATE scenes 
          SET scene_order = ?, content = ?, updated_at = ?
          WHERE id = ?
        `).run(scene.order, scene.content || '', now, sceneId);
            }

            // Replace assets for this scene
            // First delete existing links
            db.prepare('DELETE FROM scene_assets WHERE scene_id = ?').run(sceneId);

            // Insert new links
            if (scene.assets && scene.assets.length > 0) {
                // Removed asset_order column requirement, using unique index for safety
                const stmt = db.prepare(`
          INSERT OR IGNORE INTO scene_assets (id, scene_id, asset_id)
          VALUES (?, ?, ?)
        `);

                scene.assets.forEach((asset) => {
                    // If asset object has only id, use it. If it's the full object, use .id
                    const assetId = asset.id || asset.assetId;

                    if (assetId) {
                        stmt.run(randomUUID(), sceneId, assetId);
                    }
                });
            }
        }
    });

    updateTransaction(scenesData);
    return listScenesByProject(projectId);
}
